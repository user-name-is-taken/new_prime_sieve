def zipper(*args):
    """the zip method in python 3 returns a generator-style object.
    this function changes that object to a list.

    http://stackoverflow.com/questions/
    1071201/why-does-list-comprehension-using-a-zip-object-results-in-an-empty-list

    see ex 10.3
    """
    myZip=list(zip(*args))
    return myZip
class linked_dict (object):
    def __init__(self,alist):
        """all values in the list must be unique!"""
        self.d=dict()
        self.d=self.make_pointers(alist)
    def make_pointers(self,al):
        kzero=[None,al[1]]
        k_neg_one=[al[-2],None]
        k=zipper(al[:-2],al[2:])
        k=list(map(list,k))
        d=zipper(al[1:-1],k)
        d.insert(0,(al[0],kzero))
        d.append((al[-1],k_neg_one))
        d=dict(d)
        return d
        
    def remove_by_value(self,value):
        """removes by value
fails if you try to remove the last element."""
        k=self.d[value]
        try:
            self.d[k[0]][-1]=k[-1]
        except:
            pass
        try:
            self.d[k[-1]][0]=k[0]
        except:
            pass
        del(self.d[value])
    def get_previous(self, value):
        """gets previous before value"""
        return self.d[value][0]
    def get_next(self,value):
        """gets next after value"""
        return self.d[value][-1]
    def return_list(self):
        """returns the sorted list. faster than return_og"""
        l=list(self.d.keys())
        l.sort()
        return l
    def return_og(self):
        """returns list in entered order"""
        it=self.d.popitem()#item
        self.d[it[0]]=it[-1]
        down=it[-1][0]
        up=it[-1][-1]
        l=[it[0]]
        while up in self.d:
            l.append(up)
            it=self.d[up]
            up=it[-1]
        while down in self.d:
            l.insert(0,down)
            it=self.d[down]
            down=it[0]
        return l
        
